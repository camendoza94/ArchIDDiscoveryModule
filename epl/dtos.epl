pattern ImplementsSerializable
	class: ClassDeclaration
		guard: class.proxy = false and class.name.endsWith("DTO"),
	no superInterfaces: TypeAccess
		from: class.superInterfaces -> select (i | i.type.name = "Serializable") {	
	onmatch {
		var message : String;
	 	message = "Implement Serializable " + class.name;
		message.println();
		var issues = new Native("archtoring.tools.IssuesTool");
		issues.addIssueOnGithub("Implement Serializable in this DTO");
		
		var comment = new LineComment;
		comment.content = "// TODO R1: Implement Serializable in this DTO.";
		class.comments.add(comment);	
	}
}

pattern EmptyConstructor
	class: ClassDeclaration
		guard: class.proxy = false and class.name.endsWith("DTO"),
	no constructor: ConstructorDeclaration
		from: class.bodyDeclarations -> select (c | c.isTypeOf(ConstructorDeclaration) and c.proxy = false 
			and c.parameters.size = 0 and (c.body.statements.size = 0 or (c.body.statements.size > 0 and c.body.statements.at(0).isTypeOf(SuperConstructorInvocation)))) {	
	onmatch {
		var message : String;
	 		message = "EmptyConstructor " + class.name;
			message.println();
		var comment = new LineComment;
		comment.content = "// TODO R2: Add empty constructor for serializing.";
		comment.enclosedByParent = false;
		comment.prefixOfParent = true;
		class.comments.add(comment);
	}
}

pattern SerializableFields
	classDecl: ClassDeclaration
		guard: classDecl.proxy = false and classDecl.name.endsWith("DTO"),
	field: FieldDeclaration
		from: classDecl.bodyDeclarations -> select (c | c.type.type.isKindOf(PrimitiveType)) {	
	onmatch {
		var message : String;
	 	message = "Non-seriaizable fields in " + classDecl.name;
		message.println();
		var comment = new LineComment;
		comment.content = "// TODO R3: Remove or edit no-serializable field " + field.getName() + ".";
		classDecl.comments.add(comment);
		
	}
}
	
pattern GettersAndSetters
	class: ClassDeclaration
		guard: class.proxy = false and class.name.endsWith("DTO"),
	field: FieldDeclaration
		from: class.bodyDeclarations,
	no setter: MethodDeclaration
		from:  class.bodyDeclarations -> select (m | m.name = "set" + field.getName())
		optional: true,
	no getter: MethodDeclaration
		from: class.bodyDeclarations -> select (m | m.name = "get" + field.getName() or m.name = "is" + field.getName())
		optional: setter.isDefined() {
	onmatch {
		var message : String;
 		message = "GettersAndSetters " + class.name + " " + field.getName();
		message.println();
		var comment = new LineComment;
		if (getter.isUndefined()) {
			comment.content = "// TODO R4: Add missing getter for " + field.getName() + ".";	
			comment.enclosedByParent = false;
			comment.prefixOfParent = true;
			class.comments.add(comment);
		} 
		if (setter.isUndefined()) {
			comment.content = "// TODO R4: Add missing setter for " + field.getName() + ".";
			comment.enclosedByParent = false;
			comment.prefixOfParent = true;
			class.comments.add(comment);
		}
	}
}

pre {
	var entityMap = ClassDeclaration.all -> select (c | c.name.endsWith("Entity")).mapBy(c|c.name.substring(0, c.name.indexOf("Entity")));
}

pattern CreateDTOFromEntity
	class: ClassDeclaration
		guard: class.proxy = false and class.name.endsWith("DTO") and class.name.indexOf("Detail") = -1,
	no constructor: ConstructorDeclaration
		from: class.bodyDeclarations -> select (c | c.isTypeOf(ConstructorDeclaration) and c.proxy = false 
			and c.parameters.size = 1 and c.parameters.at(0).type.type.name.endsWith("Entity") and c.body.statements.size > 0 
			and c.body.statements.at(0).isTypeOf(IfStatement) and c.body.statements.at(0).expression.rightOperand.isTypeOf(NullLiteral)
			and c.body.statements.at(0).expression.operator = InfixExpressionKind#NOT_EQUALS
			and c.body.statements.at(0).thenStatement.isTypeOf(Block)
			and entityMap.get(class.name.substring(0, class.name.indexOf("DTO"))).bodyDeclarations 
			-> select (f | f.isTypeOf(FieldDeclaration) and not (f.type.type.name.endsWith("Entity") or f.type.type.name.endsWith(">"))).size <= c.body.statements.at(0).thenStatement.statements.size - 2) {	
	onmatch {
			var message : String;
		 		message = "CreateDTOFromEntity " + class.name; 
				message.println();
				var comment = new LineComment;
				comment.content = "// TODO R5: Check constructor from Entity implementation in DTO.";
				comment.enclosedByParent = false;
				comment.prefixOfParent = true;
				class.comments.add(comment);
	}
}

pattern toEntity
	class: ClassDeclaration
		guard: class.proxy = false and class.name.endsWith("DTO") and class.name.indexOf("Detail") = -1,
	no method: MethodDeclaration
		from:  class.bodyDeclarations -> select (m | m.name = "toEntity" and m.parameters.size = 0 and m.body.statements.size > 1
			and m.body.statements.at(0).isTypeOf(VariableDeclarationStatement) and m.body.statements.at(0).fragments.at(0).initializer.type.type.name.endsWith("Entity")) {
	onmatch {
		var message : String;
 		message = "toEntity " + class.name;
		message.println();
		var comment = new LineComment;
		comment.content = "// TODO R6: Check toEntity implementation in DTO.";
		comment.enclosedByParent = false;
		comment.prefixOfParent = true;
		class.comments.add(comment);
	}
}

@cached
operation FieldDeclaration getName() {
	return self.fragments.at(0).name.firstToUpperCase();
}